# Overview

Some study notes collected from various sources.

# Study Order: 

1. CTCI / Competitive Programmer's Handbook Books & Big O / Collections API cheat sheets
2. Bari/William's vids for DS&A/Paradigms - https://leetcode.com/discuss/general-discussion/494279/comprehensive-data-structure-and-algorithm-study-guide Just watch Bari's vids
3. NeetCode 150: https://neetcode.io/roadmap
4. Educative Course: https://www.educative.io/path/ace-java-coding-interview
5. LeetCode 150: https://leetcode.com/studyplan/top-interview-150/
6. LeetCode Company High Frequency: https://leetcode.com/studyplan/google-spring-23-high-frequency/
7. 12 Week Plan - https://docs.google.com/document/d/1wUCqhVHydWiDk6FJdFLSMpgigNrGcs4OFZg0Wa7JGEw/preview?pru=AAABcwwIgU8*RoGmr_8ZESReo5KaS78UnQ
8. Patterns/Questions/System Design - https://zero1code.info/topic/oc , https://medium.com/leetcode-patterns/leetcode-pattern-0-iterative-traversals-on-trees-d373568eb0ec?source=collection_home---4------2-----------------------
9. Leetcode Review and useful stuff - https://leetcode.com/discuss/general-discussion/665604/important-and-useful-links-from-all-over-the-leetcode
10. Grokking the System Design / Designing Data intensive Applications / Design Patterns GoF / https://leetcode.com/discuss/general-discussion/125038/system-design-interview-prep / https://www.youtube.com/playlist?list=PLhgw50vUymycJPN6ZbGTpVKAJ0cL4OEH3
11. https://yangshun.github.io/tech-interview-handbook/
12. Breadth MCQ - https://www.geeksforgeeks.org/a-complete-step-by-step-guide-for-placement-preparation-by-geeksforgeeks/
13. System Design More Topics: https://github.com/madd86/awesome-system-design
14. Concurrency - http://tutorials.jenkov.com/java-concurrency/index.html

> Follow problem solving processes and use Feynman method to solidify learning. Practice articulating thoughts as if in an interview.
> Learn DS&A > PARADIGMS > PATTERNS > STRATEGIES/TECHNIQUES, COMP SCI CONCEPTS, the goal is to solve NEW medium / hard problems with high success rate with speed (20 mins).
> First solve the algorithm with abstractions, solve the "business logic" first then the implementation and end-to-end logic.
> Upsolve & watch videos if you cant solve within 10 minutes Easy / 20 min Medium / 4 hours hard.
> Review weekly. Weekly competitions are good review.
> Use LC/Pramp to practise interviews.
> Practise MCQ / flashcards for the "trivia" knowledge. Anki is good.

# Templates and Cheatsheets

> You should have this table in front of you if you are having a phone interview
Power of 2 / Exact Value /         Approx. Value / Bytes into B
    7        128
    8        256
    10       1024                    1 thousand        1 KB
    16       65,536                                    64KB
    20       1,048,576               1 million         1 MB
    30       1,073,741,824           1 billion         1 GB
    32       4,294,967,296 4GB
    40       l,099,511,627,776       1 trillion        1 TB

byte	   1 byte	Stores whole numbers from -128 to 127
short	   2 bytes	Stores whole numbers from -32,768 to 32,767
int	   4 bytes	Stores whole numbers from -2,147,483,648 to 2,147,483,647
long	   8 bytes	Stores whole numbers from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
float	   4 bytes	Stores fractional numbers. Sufficient for storing 6 to 7 decimal digits
double	8 bytes	Stores fractional numbers. Sufficient for storing 15 decimal digits
boolean	1 bit	   Stores true or false values
char	   2 bytes  Stores a single character/letter or ASCII values
void     2 bytes

Code templates, Stages of an interview, and Cheatsheets (LC resource): https://leetcode.com/explore/interview/card/cheatsheets/720/resources/4723/
Big O: https://i.imgur.com/sh9wysY.png
Collections API: https://courses.cs.washington.edu/courses/cse143/17su/exams/final/cheat_sheet.pdf, file:///C:/Users/JP/Desktop/Home_folder/ME/Essential_Reading/FAANG_prep/Java/Java%20Collection%20Matrix%20-%20Java%20Collection%20Matrix.pdf
Pseudocode: https://blog.usejournal.com/how-to-write-pseudocode-a-beginners-guide-29956242698


# PRIORITY
------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------

## Daily Dues:
> Overcome mental gaps https://www.quora.com/What-is-the-best-strategy-to-improve-my-skills-in-competitive-programming-in-C++-in-2-3-months
> Deliberate practise - skill chunks, paired with feedback, progressive overloading, Mix reading/videos/solving/drilling: multiple learning styles.
> Do 2-5 LC a day, never spend more than 10m/20m/2hrs, upsolve and time.

### Concepts Review:
- Grokking Course
- Good actionable plan: https://docs.google.com/document/d/1wUCqhVHydWiDk6FJdFLSMpgigNrGcs4OFZg0Wa7JGEw/preview?pru=AAABcwwIgU8*RoGmr_8ZESReo5KaS78UnQ
- DS&A Videos: https://www.youtube.com/user/purpongie/playlists && https://www.youtube.com/playlist?list=PLDN4rrl48XKpZkf03iYFl-O29szjTrs_O
- CS major overview: http://matt.might.net/articles/what-cs-majors-should-know/
- patterns high lvl: https://medium.com/hackernoon/14-patterns-to-ace-any-coding-interview-question-c5bb3357f6ed
- more patterns + questions: https://www.educative.io/courses/grokking-the-coding-interview
- sorting: https://www.toptal.com/developers/sorting-algorithms
- Read Competitive Programming / Cracking the Coding Interview / Grockking the System Design / Designing Data Intensive Applications / Clean Code

#### Breadth / MCQ
- General breadth: https://practice.geeksforgeeks.org/courses/Placement-100 (dont sign up review the topics)
- Focus on Aptitude/MCQ here: https://www.geeksforgeeks.org/a-complete-step-by-step-guide-for-placement-preparation-by-geeksforgeeks/
- https://www.quora.com/What-basic-data-structures-and-algorithms-should-one-learn-before-starting-competitive-programming/answer/Ashish-Gupta-211?share=a2eee6ca&srid=ihpN

### Code References (Clean Code implementations):
- C++ CP: http://cp-algorithms.com/
- Java DS&A: https://github.com/williamfiset/algorithms
- Video Reference: https://www.youtube.com/user/mycodeschool

------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------

# SECONDARY
------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------
Update Dev knowledge

## Basic Networks:
- DNS Lookup/URL: http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/comment-page-3/
- sharding is involved with databases (split up data in large websites)
- load balancing - involved in DNS lookup, listens on an IP address and forwards requests to other servers
- TCP/IP - Transmission Control Protocol/Internet Protocol - rules for computer communication over network - TCP is the data delivery, IP is address
https://www.avast.com/c-what-is-tcp-ip , just know that there are 4 layers in TCP/IP datalink protocol model.
- When you navigate to a url in browser: URL > DNS Lookup (load balancing) > HTTP Request from browser (load balancing) > TCP connection open for requests (cookies sent) > Follow Redirects (SEO involved) > HTML Response from Server with embedded objects in HTML > Browser sends HTML Requests for URLS for objects in HTML page recursively, following same process as original HTML (static/dynamic pages handled differently) > Browser continues to send AJAX Requests
- AJAX - Asynchronous JavaScript and XML

## Dev Stuff:
- inject automated testing (unit tests, integration tests, end to end tests) ** this will make you stand out
- it is generally better to improve 2-3 projects than have more. Have you included error handling, unit / integration tests, build tools in your projects? I would start with these, and can take a basic project to being an exceptional project, even if the functionality is the same.
- Kubernetes, Dockers, AWS, Heroku, Google Cloud (Cloud Services/Platform)
- Microservices
- Multi-threading / concurrency
- Know request response cycle, REST, CRUD, databases
- Dont master everything, but atleast have some breadth on everything so you can at least talk about it
- Test Driven Development / QA (unit tests/integrated tests/end to end tests), Junit
- DevOps (CI/CD), Jenkins, AWS, GCP, Terraform, Kubernetes, Docker
- Be able to confidently implement CRUD interactions with some kind of database, via REST API, know how to consume REST APIs (Node/Express)
- Java/C++ for backend
- Python for Scripting
- ES6 Javascript, React for frontend

### System Design / Development / Implementation:
https://leetcode.com/discuss/career/216554/From-0-to-clearing-UberAppleAmazonLinkedIn
- Strong database knowledge: start a project from just the database
- MEAN/MERN stack for quick building/learning
https://github.com/madd86/awesome-system-design
https://leetcode.com/discuss/interview-question/system-design/786972/coupon-management-system-system-design-interview

### Testing
- “How to design practical test cases.” A how-to article on test-case design by an author from a
Japanese company that has a good reputation for delivering software with very few faults.
(T. Yamaura, IEEE Software, 15(6), November 1998) http://dx.doi.org/10.1109/52.730835.

- “Test-driven development.” This special issue on test-driven development includes a good general
overview of TDD as well as experience papers on how TDD has been used for different types of
software. (IEEE Software, 24 (3) May/June 2007).

- Exploratory Software Testing. This is a practical, rather than theoretical, book on software testing
which develops the ideas in Whittaker’s earlier book, How to Break Software. The author presents a
set of experience-based guidelines on software testing. (J. A. Whittaker, 2009, Addison-Wesley).

- How Google Tests Software. This is a book about testing large-scale cloud-based systems and
poses a whole set of new challenges compared to custom software applications. While I don’t think
that the Google approach can be used directly, there are interesting lessons in this book for large-
scale system testing. (J. Whittaker, J. Arbon, and J. Carollo, 2012, Addison-Wesley).

------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------



# REVIEW:
------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------

Basic DS&A: https://github.com/kdn251/interviews#articles

Focus on these concepts:
word search 12， word break12，word ladder12，LIS，sort color，LRU，insert & delete in O1，rob house123，234sum. You should be able to solve these with your eyes closed. 
Min/max heap，bucket sort，topological sort，binary pre/in/post/level order，combination/permutation(backtracking) should appear in your dreams when you're asleep.

DS&A:
- Linked List
- Trees and Graphs and Tries (adj matrix/list)
- Arrays and Strings and Matrix
- Stacks and Queues
- Hashing
- Sortings and Searching
- BFS/DFS

5 Major Topics:
- Implementation
- Programming Paradigms: Greedy, Backtracking, Branch and Bound, DP, Divide and Conquer, Brute Force
- Graph Theory: directed (digraphs), undirected, weighted, rooted(in & out) and unrooted tree, DAG, Bipartite, Network Flow
- Math: Number Theory, Geometry, Combinatorics, Linear Algebra
- Others: Strings, Bit Manipulation, Permutations, Parentheses

Patterns:
https://medium.com/hackernoon/14-patterns-to-ace-any-coding-interview-question-c5bb3357f6ed#4a09
- Sliding Window
- 2 Pointers
- Fast/Slow pointers
- Merge Intervals
- Cyclic Sort
- Reverse a linked list
- BFS
- DFS
- 2 Heaps
- Subsets
- Binary Search
- Top K elements
- K-way merge
- Topological sort

INTERMEDIATE DS&A:

Analysis:
- Asymptotic notation
- Big O
- Discrete math proofs

Data Structures:
- Vector
- Priority Queue
- Heap
- Union Find

Search Trees and Skip Lists:
- ordered dictionary
- binary search tree
- AVL tree
- Multiway search trees
- 2,4 trees
- red black trees
- Min cost spanning tree (prims and Kruskals)

Sorting, Sets, Selection:
- Divide and Conquer: merge-sort, quick-sort
- Bucket array: bucket sort, radix sort

Fundamental Techniques:
- Recursion: Fibonacci
- Greedy: knapsack, scheduling, prims and kruskals, job sequencing, optimal merge
- Divide and Conquer: merge-sort, quick-sort
- Dynamic Programming: subproblems

Graphs:
- Edge list
- Adjacency list
- Adjacency matrix
- BFS
- DFS
- Bipartite graph

Weighted Graphs:
- Djikstra's
- Bellman-Ford
- SSSP DP
- SSSP Matrix-multiplication

Network Flow:
- Ford-Fulkerson (Max / min flow)
- Edmonds Karp (better Ford-Fulkerson using BFS)
- Capacity scaling FF
- Dinic
- Push Relabel FF

Strings:
Pattern matching:
- Brute Force
- Boyer Moore
- Knuth-Morris-Pratt
- Rabin Karp
Encoding/Retrieval:
- Tries, compressed tries, compact tries, encoded tries
- Suffix/prefix Trees
- Suffix arrays
- Huffman coding

Lazy Initialization:
- Store and defer calculations till we need to retrieve (Stack with increment)


------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------

# LC NOTES
------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------

Aim for bug-free solution for medium in 15 min, need to practise until we can get a clean and bug free sol!
Just aim for readability, dont follow LC one liner mentality

Patterns and LC's:
https://www.educative.io/courses/grokking-the-coding-interview

Always do boundary checks, edge cases, special cases
Use more ternary function: a = a != null ? a.next : headB;

Study Notes:
https://blog.usejournal.com/how-to-write-pseudocode-a-beginners-guide-29956242698 pseudocode
https://www.journaldev.com/1663/java-generics-example-method-class-interface#:~:text=2.-,Java%20Generic%20Class,to%20specify%20the%20type%20parameter.&text=Notice%20that%20while%20using%20this,can%20produce%20ClassCastException%20at%20runtime.

byte: The byte data type is an 8-bit signed two's complement integer. It has a minimum value of -128 and a maximum value of 127 (inclusive). 
thread-safe: use lock

HashMap vs HashSet: map allows multiple values, set does not. Both are not thread safe, and not synchronized, they can be synchronized using Collections 
Set uses elements only, not K,V
Hashtable is synchronized but deprecated legacy code


Algorithm analysis
1. Asymptotic Analysis: (worst case, "estimate" run-time from primitive operations, this is actually closer to Big-Theta)
2. Proofs: Closed-form solution for recurrence, Iterative substitution (plug and chug), recursion tree, guess and test (proof by induction), master method
3. Big-O Solution: (upper bound c for a range n) (T(n) <= cn for all n >= n0), you say "There are positive constants c and n0 such that f(n) <= cg(n) for n >= n0. Need c > 0 and n0  >= 0" 
4. Space Complexity:
5. If needed, amortized analysis (Big-Theta(tight bound) and Big-Omega(lower bound) may be helpful here)

Master method: (If the recurrence relation is in a certain format you can use it)
If T(n) = aT(n/b) + f(n)
where n >= d
Look it up, hard to memorize


Analysis methods:
- runtime using internal clock
- primitive operations
- Big O notation (the mathematical)
int count = 0; // Count for comparisons
long startTime = System.nanoTime(); // Starting time using nanoseconds
long endTime = System.nanoTime(); // End time once algorithm finishes
System.out.println("Comparisons: " + count + " and " + (endTime - startTime) + " milliseconds");

Proof by Induction:
- Proof definition
- Base case
- Inductive Step (Assume)
- Test
- Conclusion

Do not be confused: Best/Average/Worst case does not imply Big-O family notations. they are not equal, however we set bounds using Big-O to describe them

Some Big-O:
- Find all subsets of a set - O(2^n)
- Find all permutations of a string - O(n!)
- Iterate all cells in a matrix - O(nm)
Big-Oh Notation:
-given f(n) and g(n), we say that f(n) is O(g(n)) if there are positive constants c and n0 such that f(n) <= cg(n) for n>=n0, where n0 >= 1
- aka find the upper bound: f(n) <= cg(n) for all n>= n0

Proofs:
-example(counterexample)
-contrapositive/contradiction (DeMorgan's Law)
-induction (base case and build induction step)
-loop invariant

Big O family:
- Big O: (inclusive) upper bound (set of all functions in this family bigger than f(n))
- Big Omega: lower bound
- Big Theta: tight bound (average case)
- little o: (strict) upper bound


Java util.Arrays.sort() is Onlogn time, O(n/2) space

Acronyms:
-BQDS


Recursion:
- Base case / recursive case, aka induction step (also known as recurrence relation/equation, inductive step in math)
- You can solve relation equations by finding a closed form solution (only has T(n) on one side), then performing analysis
- sometimes you can express with floor and ceiling functions (aka closed form, non recursive)
- Exit case / in between conditions / Solving as if you have already solved the subproblem
- Usually recursion is top-down, as if you have already solved the subproblem, DP is bottom up, DP will avoid stack overflow
- Can analyze with: recursion tree, Master method

- Remember that recursion uses a stack, a trick is to use recursion to reverse order (Reverse Immutable Linked List)

Recurrence Relations:
- Base case
- General case

Recurrence	Algorithm	Big-Oh Solution
T(n) = T(n/2) + O(1)	Binary Search	O(log n)
T(n) = T(n-1) + O(1)	Sequential Search	O(n)
T(n) = 2 T(n/2) + O(1)	tree traversal	O(n)
T(n) = T(n-1) + O(n)	Selection Sort (other n2 sorts)	O(n2)
T(n) = 2 T(n/2) + O(n)	Mergesort (average case Quicksort)	O(n log n)

- Nested List Weight Sum: can solve is Recursion

PATTERNS:

Sliding Window:
- **Longest Substring with K Distinct Characters** - you can use map or ASCII [256] cache. Use while map.size() > k move left. Watch the edge cases. Use the DP approach: res = Math.max(res, r-l +1);
- Min window substring: track counts for formed and required, as well as a dictionary for unique chars: remember. We can save the word as a stringbuilder, or in an array with indices
Remember: windowCounts.getOrDefault(c, 0); windowCounts.put(c, count + 1); and map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0) + 1);
- Sliding Window Max: keep deque of size k, hold index of max element

Two Pointers:
- Sort Colors: Sorting count
- Remove Duplicates from Sorted Array 2: At most K duplicates
- Partition Labels: 2 Pass, track the last index, not count
- 3 Pointers: use i, l = i+1 and r = len-1. use while l<r to drive the algo

Fast and Slow:
- basic is the have fast and slow ptr, fast goes 2x speed fast = head; fast = fast.next.next; when they meet, a cycle is detected. If there is ever a null node that means there is no cycle
- linked list cycle proof: scenario A. if fast = slow-1: next itr will be slow-1+2 and slow will be slow + 1; B. if fast = slow-2, fast will = slow and slow will be slow+1, which = scenario A.
- find length of cycle: Once fast = slow, save slow ptr and iterate the cycle with a new ptr to find length of cycle K. Use a do while loop in separate function.
- start of linked list cycle: find K, move ptr2 ahead by K nodes, then increment both at same speed until they both meet. That is the start of the cycle. ptr 2 must have completed 1 loop in cycle.
- Happy Number: each number will definitely have a cycle. Find the cycle and see if cycle is stuck on number 1. Need to separate digits with while loop and modulus. Time complexity is O(logN), O(1) space.
1. find if there is cycle
2. find length of cycle K, need to use a do while loop
3. find cycle start by new ptr, move ahead by K, then find intersection of K & slow ptr
- Linked Cycle II (O(1) space follow up): You can just keep slow ptr there and start ptr2 from head and increment together and they will meet at the cycle start. Check the proof: https://leetcode.com/problems/linked-list-cycle-ii/discuss/44774/Java-O(1)-space-solution-with-detailed-explanation.
- Intersection of 2 linked lists: swap the ptrs to the head of the other list if reach null, until both equal, then see if null or a node


Merge Intervals:
- Know the 6 cases: a and b do not overlap, overlaps - b ends after a, a completely overlaps b, overlaps - a ends after b, b completely overlaps a, no overlap - b before a
- Know Iterator: Iterator<Interval> intervalItr = intervals.iterator(); while (intervalItr.hasNext()) Interval interval = intervalItr.next();
- First sort by start time: Arrays.sort(intervals, (a, b) -> Integer.compare(a.start, b.start));
- First determine the cases, then come up with the main logic
- this Algo is mostly just finding each interval condition, not really a trick involved, just tricky implementation
- Intervals Intersection: 5 cases: logic is start = max(a.start, b,start); end = min(a.end, b.end)
- Conflicting Appointments
- Course Schedule

Cyclic Sort:
- usually unsorted array range 1 - n, but can have duplicates, some nums will be missing. Just try placing each num in correct place, then iterate to find indices that are missing correct nums
- Find missing number, we sort nums[i] < nums.length, we cant put n in the array since length = n-1
- Find duplicate no extra space: if while swapping, the numbers are the same, return that num
- Find duplicate num without modifying array: you have to use fast and slow pointer method to find the start of the cycle, as a duplicate number will cause a cycle in the cyclic sort

Reverse Linked List:
- Just create a dummy null node to mark head
- remember: need Node curr, prev, next; while (curr != null) next = curr.next; curr.next = prev; prev = curr; curr = next; return prev
- Reverse sublist: skip p-1 nodes, curr will point to pth node, do the reversal between p and q, then connect with first part
- you can define a reverse() function for trickier questions
- Reverse every K-element Sub-list
- Remember how to delete nodes: skip to n+1 and make n-1's next n+1.

BFS:
- Use a Queue!, remember to put root in q, while q !isEmpty, track size of q, for size of q, remove node, do computation, then insert the children of the node into the q
- Reversing order, just put values in the list at whatever end you need (Invert Tree)
- Min depth of Binary Tree: just tracking depth, check for leaf node with both children null
- Max depth, same as above but just track max, dont return till end and return max
- Diamater of Binary Tree: this is max depth
- Level order successor, just remove next node in the q after we find key
- Flatten Binary Tree to LL
- Connect Level Order: same as above but connect to prev
- Binary Tree Right Side View: this is connect Level Order
- Lowest Common Ancestor of Binary Tree
- **Jump game 2**: greedy + BFS

DFS:
- Recursive Stack, at every step, just make 2 recursive calls, one for left and one for right
- root to leaf
- Nested List Weight Sum
- Binary Tree Path sum: subtract each node from S, check each node if its a leaf and if so is it = to S
- All paths Binary Tree sum, store the above in a list
- Sum of path numbers
- Binary Tree Max Path sum: just use Math.max to backtrack all case at each node, DFS to traverse

2 Heaps:
- need one for smaller nums than k and one for larger
- median of a number stream: if odd, return either top of smaller or larger heap, if even, return median of both/ This gives O(logN) time, better than O(n)
 PriorityQueue<Integer> maxHeap; //containing first half of numbers
 PriorityQueue<Integer> minHeap; //containing second half of numbers
maxHeap = new PriorityQueue<>((a, b) -> b - a);
minHeap = new PriorityQueue<>((a, b) -> a - b);
- sliding window median
- maximize capital (greedy): add all project capitals to a min heap, select a project with smallest capital requirement.
Go through the top projects of min heap and filter projects that can be completed within our available capital. Insert the profits into a max heap, so we can choose a project with max profit.
Select the top project of the max heap for investment
Repeat step 2 and 3 for required num of projects

Subsets:
- Permutations and Combinations
- BFS approach can handle all such problems
- Subsets: start with empty, for each i, add i to all existing subsets
- Subsets with Duplicates: first sort, then check curr and prev, if duplicate, only add to subsets created in previous step
- Permutations: BFS again like subsets, but each permutation must contain all numbers. At each level, add current number to each position, use a list for permutations, old permutation and new permutation
do it recursively so it is more concise and elegant
- balanced parentheses

Sorting:
-n^2 sorts: bubble sort, inversion,
-nlogn sorts: it is not possible to sort an array faster than nlogn time if comparing array elements
- mergesort, quicksort
-Counting Sort (remember that it is stable) - Sort Colors: https://leetcode.com/problems/sort-colors/discuss/26500/Four-different-solutions, On+k
- Quick Sort: Nuts and Bolts
-Bucket Sort - buckets > insertion sort > merge On + k time worst On^2
-Lexicographic sort (just radix sort)
-Radix Sort - Counting sort on last digit, then sort by next digit, then counting sort by the next digit, repeat until sorted Onk time
-Quick Select - use the pivot/partition, returning using index Onlogn/On^2
-Deterministic select - median of medians as pivot to find quick select pivot

Binary Search: 
- check middle, recursion
- start = 0; end = arr.length - 1; middle = start + (end - start)/2
- if key is not == middle, check key < middle: end = mid - 1; check key > middle: start = mid + 1
- if start > end, return -1; or do while (start <= end)

- Sorted arrays (you can also sort first)
- Binary Search in rotated sorted array
- Jump binary search
- Data compression
-File merging
-MST, Kruskal, Dijkstra
- number range:update end = middle - 1 and start = middle + 1
- Binary Search on infinite array: to handle, start with bounds size as 1 and double it each time until find bounds that can have the key, and then perform the search

Bitwise XOR:
XOR 2 of the same numbers returns zero, returns the same number if XOR with zero
- Missing Number:
- Single Number: find non-duplicate: just xor all the nums with themselves
- 2 Single Numbers: 

Top K Elements:
Use a Heap of size K, replace root with num that we need if bigger or smaller, peek(), poll(), add()
We use Max Heap to find lowest number and vice versa, because we want to obtain the root number
- K smallest/largest number: just straightforward use heap
- K closest Points to the origin: use a max heap, calculate Euclidean distance using sqr(x^2 + y^2) to find closest point to origin, (the root is the max or furthest)
- Connect Ropes (Greedy): use Min Heap and add all values, then go through heap and take top and connect and push back, until heap is left with only one rope
- Top K Frequent Numbers: Use HashMap for frequency map, then use a Min Heap to find K most frequently occurring number
- Frequency Sort: same thing but with characters


K-way Merge:
Again using a Heap. The key is that there are multiple lists
Just take elements from each list and put into a heap, then take the top of the heap and put it in the merged list
- Merge K Sorted Lists
- Kth Smallest Number in M Sorted Lists: straightforward except making a merged list, just track how many elements have been inserted. When count = K, found.
- Kth Smallest Number in a Sorted Matrix: same as above, each row is basically a list
- Smallest Number Range:


Topological Sort:
Key concepts: Source (node with no incoming edge), Sink (node that only has incoming edges), Topo sort starts from source and ends at sink.
Topo ordering is possible only when graph has no directed cycles. needs to be a Directed Acyclic Graph (DAG).
You can traverse the graph in a BFS from all sources, save to a sorted list, remove all sources and their edges from the graph. After removal of edges, there will
be new sources, so repeat until all vertices are visited.
- You need an Adjacency List, 2 HashMaps (another List of children, and in-degrees), and a Queue.

To implement:
A. Initialization:
1. store graph in adj lists, each parent vertex will have a list containing all of its children, using a HashMap, where K will be the parent vertex number and the value will be a List containing children vertices
2. To find sources, keep a HashMap to count the in-degrees. Any vertex with 0 in-degree will be a source
B. Build the graph and find in-degrees of all vertices
1. Build the graph from the input and populate the in-degrees HashMap
C. Find all sources:
1. All vertices with 0 in-degrees will be our sources and store them in a Queue
D. Sort:
1. For each source, do:
- Add it to the sorted list
- Get all of its children from the graph
- Decrement the in-degree of each child by 1
- if a child's in-degree becomes 0, add it to the sources Queue
2. Repeate step 1, until the source Queue is empty.

- Tasks Scheduling

Miscellaneous:
- Kth Smallest Number

PARADIGMS:

Divide and Conquer:
- Divide problem into smaller, non-overlapping chunks, conquer by solving sub-problems recursively, combine to solve the original problem
- Binary Search, Merge Sort, Quick Sort are common D&C algos
-Proofs: Closed-form solution for recurrence, Iterative substitution (plug and chug), recursion tree, guess and test (proof by induction), master method
-The Master Theorem
-Integer multiplication
-Matrix Multiplication

Backtracking:

Greedy:
 (recurrence function, greedy choice leaves one subproblem)
- Greedy is like the precursor to DP, where DP would be overkill
- Jump game 1,2
- fractional knapsack problem - use heap-based PQ (Onlogn)
- usually the first choice is made before solving any subproblem (Top down)
Steps:
1. Divide the problem into subproblems, including one small problem and the remaining subproblem
2. Determine the optimal substructure of the problems (formulating a recurrence function)
3. Show that if we make the greedy choice, then only one subproblem remains
4. Validate the rightness of the greedy choice
5. Write either a recursive or an iterative implementation

Types or Greedy Algos:
- Acitivity Selection
- Frog Jumping
- Data Compression
- File Merging
- Graph Algos, such as MST (prim and Kruskal), Min path (Dijkstra), for negative values, have to use DP such as Bellman Ford

Greedy Proofs:
- Exchange arguments
- Greedy Stays ahead


Branch and Bound:

Dynamic Programming: (next step from Greedy)
- requires a sequence of decisions to optimize. Picking the best possible solution
- Build a solution matrix step by step
- Recursive solution will be O(2^n) time
- DP offers 2 methods: **Top-down with Memoization**: storing results of already solved subproblems, we solve recursively but save space and Bottom-up with Tabulation, fill up an n-dimensional table
- Memoization: (top down) just check at each computation if N is in cache, then return the result from cache. Make a new function that you can pass cache and recursive N into. Memoization will be O(n*m)
- When we memoize, we need to introduce a state. You can use a Boolean HashMap, <String, Boolean>; current can be = x + "" + y, to make sure it concats the string
- Tabulation: (bottom up): fill a table, and based on results in table, solution to the top problem is computed.
- We first always find a brute-force recursive solution, then apply memoization and/or tabulation
- you need to recursively return the max of some pre-defined cases

A good approach is:
1. Find recursive relation - define the base case and the recursive relation in your naive recursive function, start from the end (top)
2. Recursive (top-down)
3. Recursive + memoize (top-down) - memoization is dealing with overlapping sub-problems, just store results in a 2d array cache, and each recursive iteration, check the cache
4. Iterative + memoize (bottom-up)
5. Iterative + N variables (bottom-up)

A template is:
1. Preprocess / Define Base cases
2. Main problem definition: define the states

The cache looks like: dp[index][vals];
Bottom up, you try to iteratively populate dp[][], each step should have different cases

- usually start with the first step chosen already (skip first step then in next step get it with max or min)

- Coin Change 2: Knapsack problem / https://youtu.be/jaNZ83Q3QGc
- Divisor game: return N % 2 == 0; Base cases: N=3, N=2; A:2 is a win, else lose. How to get N=2 to win?
if A will lose for N, then A must win for N+1, becase A can just N - 1. For any odd number N, only has odd factors, so after first move, it will be an even number. You need to prove by induction: N=1, N=2, N=3, N=4
- Paint houses: pick a color, then the next house cant be the same color, so you pick the minimum cost color, at the end, you would return the minimum value of the last row. We are working with the given 2d array
You can have each first choice of color, then track each option for the minimum of that choice, iterate, and then at the end return the minimum of all 3 choices.
Use Math.min(Math.min(a,b),c) for 3 choice minimum
- Min Cost Climbing Stairs: start with i=2, always return min of cost[i-1] and cost[i-2]. Then at the end, return the min of those.
- Partition Equal Subset Sum: check if S is even or not, since we are looking for S/2

0/1 Knapsack:
- xi = 0/1 x = {1,0,0...}
- Min(max) path to reach a target: approach: get optimal sum of k-1, then add current state (Kadane's), recursion is used
- Merging intervals: approach: find optimal solution for every interval (e.g. left, right and current separately)
- DP on Strings: usually if s1[i-1] == s2[i-2] dp something, else dp something else
-Edit distance / Levenshtein distance on Strings
- Decision Making: approach: decide whether or not to use current state: if you decide to use current, use prev. result where value was ignored and vice/versa
- Equal Subset Sum Partition: equals find subsets that has total sum of S/N (S/2 for 2 subsets)

Unbounded Knapsack:



Complete Search: general method, can brute force almost any algo, if you cant, hint to use greedy or dp


Data Structures

Generating Subsets:
- 1: recursion, maintain subset from 0 to k, when called with k, decide whether to include element k in subset or not, then calls itself with parameter k+1
- 2: bit vector: each subset of set of n elements can be rep's as a seq of n bits, which correspond to an integer b/w 0...2^n-1, 1s in bit seq are elements which are included. Convention is last bit corresponds w/ element 0

Generating Permutations:
- 1: recursion
- 2: iteratively

Vectors: - extends the notion of array by storing sequence of arbitrary objects, can access with rank (# elements preceding it)
- implementation: array-based

Heaps:
- Vector based heap implementation
- Height of a heap
- Heapsort
- Merge heaps
- Upheap
- Downheap
- Update last node
- Bottom up heap construction
- Priority Queue using Heap

Strings:
- Remember Stringbuilder!
*** StringBuilder sentence = new StringBuilder(); for (String w: words) sentence.append(w); return sentence.toString(); ***
*** Remember to convert char[] to String: String str = new String(arr); ***
- Palindromes
- Permutations

- Remove Vowels: use string buffer with sb.append(charAt(i)) for O(n), know String.replaceAll() standard function and be able to explain it. Remember that just String += character is potentially O(n^2) time because it makes a new copy

Hashmap:
- implement HashMap: use array with Linked List chaining collision resolution, or open addressing with load factor and rehash
https://stackoverflow.com/questions/40471/what-are-the-differences-between-a-hashmap-and-a-hashtable-in-java#:~:text=Hashtable%20is%20synchronized%2C%20whereas%20HashMap,any%20number%20of%20null%20values.
- Synchronized means only one thread can modify a hash table at one point of time (can cause deadlocks)
- Iterators called on HashMap are fail-fast (aka fail-safe) because they operate on a clone of the collection. Iterators will iterate through the actual structure and concurrent modifications during iteration will throw exceptions, so you know if you modified the map during iteration
- Hashmap is non synchronized, hashtable is synchronized and is thread safe. Hashmap allows one null key and multiple null values, hashtable does not allow null keys or values. HashMap is generally preffered unless thread synchronization is needed.
- Hashmap has LinkedHashMap, so you can easily swap them out. If you need synchronization you can also use ConcurrentHashMap. Unsynchronized Objects perform bettter than synchronized ones.
- Hash table is considered legacy code.
- Multimapping - Maps of maps or other DS's
- FIFO/LIFO cache
- ConcurrentHashMap - for multithreaded apps
- EnumMap
- to iterate, use map.forEach((key, value) -> dosomething);  // called a Lambda expression. or use entrySet()
- use getOrDefault
- map.containsKey();
- map for chars is called dictionary

- Duplicate Numbers: use HashSet (cannot store duplicates!)
- (Async) Logger Rate Limiter - Use lock if you want to use concurrency implementation. There is HashMap implementation (O(1) but lots of memory (never stops growing)), 2 Sets, Queue and Set
- **Island Perimeter** - Flood Fill / Max Area of Island
- **LRU Cache** - its a (Double) LinkedHashMap (Java Collections has). Need to work with a Node as wrapper. Watch null pointer with map.get(key) != null
- **LFU Cache**

Linked List:
- remember that you need the Node class (w/ class variables) and Node constructor (to set instance variables) and the LL class variables, the LL methods work with the LL instance variables
- Alot of questions are just adding a feature to the Node class (tracking max or min at each node, etc.)
- Alot of tracking some sort of cache
- know LL traversals, forward, reverse, circular, LL reversing, know collision resolution
- Add 2 Numbers: Use dummy node, pointer node, also use temp nodes for both l1 and l2. Work with pointer node, but return dummy.next at end, carryover is 0 or 1

Stack:
- Next Greater Element
- Min Stack: use linked list, each node stores its own min value, use private class Node
- Stack with increment, use arrayList or Lazy Implementation

Queue:
- Design Circular Queue (aka. Ring Buffer): benefit is that we can use space in front of the queue: use LinkedList or array with rear = (rear + 1) % a.length; front = (front + 1) % a.length;
- Know how to implement Dequeue

Dictionary / Hash tables: 
- Hash function
- hash table
- hash value
Hashcode maps:
- hashcode map: h1: keys -> integers
- compression map: h2: integers -> [0, N-1]
mapping methods:
- memory address
- integer cast
- component sum
- polynomial accumulation
compression maps:
- division
- multiply, add and divide (MAD)
collision handling:
- chaining
- linear probing: open addressing
- double hashing

Arrays:
- When you need a dynamically resizable array, just us e an ArrayList, so you dont have to implement it yourself (doubling is O(n) time but amortized is O(1))
- (Kadane's) Max subarray sum: O(n^3): triple nested loops, O(n^2): sum as subarray moves, O(n): Kadane's: each index k = the max subarray between k-1 and k-1 + itself
sum = max(array[k], sum+array[k]);
best = max(best , sum);
- Tic Tac Toe: make sure to account for nxn board, followup is generally change the game conditions (code reusability), just check every condition

Matrix/Grid:
- Walking Robot Simulation: remember the direction array: dx [0,1,0,-1] dy [1,0,-1,0] etc.
- SubrectangleQueries O(n) time: use Lazy linear search of operations. Brute Force eager is O(m*n)

Linked Lists: Always maintain head, tail, pointer(s)

Grids:
- Use direction vectors and loop over it to explore neighbors
- You can use one queue for each dimension, to avoid using wrapper and scales better in higher dimensions

Trees:
- Binary Trees: represent using array with formula (left child i = 2i+1, right child i = 2i + 2)
- Arithmetic Expression Tree: internal nodes are operators and external nodes are ints
- Decision Tree
- Euler Tour Traversal
- Prefix Tree (Trie)
- Suffix Tree
- AVL tree (self balancing BST w/ height of children <= 1
- Iterative Inorder Tree Traversal

- Merge 2 Binary Trees, remember if t1 = null return t2, use recursion and share node


Graphs: ask directed/undirected? edges weighted? sparse or dense? adj matrix, adj list, edge list?
- Shortest path problem: BFS(unweighted), Dijkstra's, Bellman-Ford, Floyd-Warshall, A*, and more
- Connectivity: Union find or DFS
- Negative Cycles: Bellman-Ford and Floyd-Warshall
- Strongly Connected Components (self-contained cycles within digraph): Tarjan's and Kosaraju's
- Traveling Salesman: Held-Karp, branch and bound, approximation
- Bridges/Cut Edge & articulation points
- Minimum Spanning Tree (MST) - subset of edges that connects all vertices together without any cycles and with min possible total edge weight: Kruskal's, Prim's & Boruvka's
-Network flow: Max Flow: Ford-Fulkerson, Edmons-Karp & Dinic's
- DFS is the base for many patterns/problems, very important, understand it deeply, https://www.baeldung.com/java-depth-first-search
- SSSP: use topsort
- Longest path on DAG
- Bipartite graph - 2-color graph
- Coloring a Graph with DFS (Number of Islands)



INTERMEDIATE DS&A

Analysis:
- Asymptotic notation
- Big O
- Discrete math proofs

Data Structures:
- Vector
- Priority Queue
- Heap
- Union Find

Search Trees and Skip Lists:
- ordered dictionary
- binary search tree
- AVL tree
- Multiway search trees
- 2,4 trees
- red black trees
- Min cost spanning tree (prims and Kruskals)


Sorting, Sets, Selection:
- Divide and Conquer: merge-sort, quick-sort
- Bucket array: bucket sort, radix sort

Fundamental Techniques:
- Recursion: Fibonacci
- Greedy: knapsack, scheduling, prims and kruskals, job sequencing, optimal merge
- Divide and Conquer: merge-sort, quick-sort
- Dynamic Programming: subproblems

Graphs:
- Edge list
- Adjacency list
- Adjacency matrix
- BFS
- DFS
- Bipartite graph

Weighted Graphs:
- Djikstra's
- Bellman-Ford
- SSSP DP
- SSSP Matrix-multiplication

Network Flow:
- Ford-Fulkerson (Max / min flow)
- Edmonds Karp (better Ford-Fulkerson using BFS)
- Capacity scaling FF
- Dinic
- Push Relabel FF

Strings:
Pattern matching:
- Brute Force
- Boyer Moore
- Knuth-Morris-Pratt
- Rabin Karp
Encoding/Retrieval:
- Tries, compressed tries, compact tries, encoded tries
- Suffix/prefix Trees
- Suffix arrays
- Huffman coding


ADVANCED:
-Sampling with Fast Fourier Transform


Codeforces:
https://codeforces.com/profile/Petr - red Java
Java template: https://codeforces.com/blog/entry/7018
https://pastebin.com/fG4qhvnG

------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------

# LINKS
------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------


# Interview Basics:
Technical Interview Study Guide pdf: https://github.com/khanhnamle1994/technical-interview-prep/blob/master/Technical-Interview-Study-Guide.pdf
https://medium.com/@nick.ciubotariu/ace-the-coding-interview-every-time-d169ce1fd3fc

# Data Structures Basics:
https://www.youtube.com/user/purpongie/playlists - William Fiset Just watch all of his playlists when you have spare time
https://www.youtube.com/playlist?list=PLDV1Zeh2NRsB6SWUrDFW2RmDotAfPbeHu - William Fiset
https://www.hackerrank.com/domains/data-structures
https://www.hackerrank.com/domains/algorithms?filters%5Bsubdomains%5D%5B%5D=implementation&badge_type=problem-solving

# Algorithm Basics:
https://www.youtube.com/playlist?list=PLDN4rrl48XKpZkf03iYFl-O29szjTrs_O - Optional

# General Review:
https://github.com/liyin2015/Algorithms-and-Coding-Interviews

# Pattern Basics:
https://medium.com/leetcode-patterns/leetcode-pattern-0-iterative-traversals-on-trees-d373568eb0ec?source=collection_home---4------2-----------------------
https://medium.com/hackernoon/14-patterns-to-ace-any-coding-interview-question-c5bb3357f6ed

# Binary Search:
https://leetcode.com/discuss/general-discussion/691825/binary-search-for-beginners-problems-patterns-sample-solutions
https://leetcode.com/problems/binary-search/discuss/423162/Binary-Search-101-The-Ultimate-Binary-Search-Handbook
https://leetcode.com/problems/ugly-number-iii/discuss/387539/cpp-Binary-Search-with-picture-and-Binary-Searhttps://leetcode.com/problems/split-array-largest-sum/discuss/89819/C%2B%2B-Fast-Very-clear-explanation-Clean-Code-Solution-with-Greedy-Algorithm-and-Binary-Search
https://leetcode.com/problems/find-k-th-smallest-pair-distance/discuss/109082/Approach-the-problem-using-the-%22trial-and-error%22-algorithm


# Bit Manipulation:
https://www.hackerearth.com/practice/basic-programming/bit-manipulation/basics-of-bit-manipulation/tutorial/
https://www.topcoder.com/community/competitive-programming/tutorials/a-bit-of-fun-fun-with-bits/
https://leetcode.com/problems/sum-of-two-integers/discuss/84290/Java-simple-easy-understand-solution-with-explanation
https://leetcode.com/problems/sum-of-two-integers/discuss/84278/A-summary%3A-how-to-use-bit-manipulation-to-solve-problems-easily-and-efficiently

# Recursion: 
https://leetcode.com/articles/a-recursive-approach-to-segment-trees-range-sum-queries-lazy-propagation/

# Sliding Window:
https://leetcode.com/discuss/general-discussion/657507/sliding-window-for-beginners-problems-template-sample-solutions
https://leetcode.com/problems/find-all-anagrams-in-a-string/discuss/92007/sliding-window-algorithm-template-to-solve-all-the-leetcode-substring-search-problem

# Interval:

# Tree:
https://leetcode.com/discuss/general-discussion/680706/article-on-trie-general-template-and-list-of-problems - Trie

# Graph:
https://www.youtube.com/watch?v=09_LlHjoEiY
https://leetcode.com/discuss/general-discussion/655708/graph-problems-for-beginners-practice-problems-and-sample-solutions

# Greedy:
https://leetcode.com/discuss/general-discussion/669996/greedy-for-beginners-problems-sample-solutions
https://medium.com/algorithms-and-leetcode/greedy-algorithm-explained-using-leetcode-problems-80d6fee071c4

# DP: 
> Top down / bottom up
https://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems
https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns
https://leetcode.com/problems/minimum-path-sum/discuss/344980/Java.-Details-from-Recursion-to-DP.
https://leetcode.com/discuss/general-discussion/651719/how-to-solve-dp-string-template-and-4-steps-to-be-followed
https://leetcode.com/problems/longest-palindromic-subsequence/discuss/222605/dp-problem-classifications-helpful-notes

# BackTrack:
https://medium.com/algorithms-and-leetcode/backtracking-e001561b9f28
https://leetcode.com/problems/permutations/discuss/18284/Backtrack-Summary:-General-Solution-for-10-Questions
https://leetcode.com/problems/permutations/discuss/18239/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partioning)

# Other:
- Calculator problems: 
https://www.cnblogs.com/grandyang/p/8873471.html
- Reverse Pairs:
 https://leetcode.com/problems/reverse-pairs/discuss/97268/General-principles-behind-problems-similar-to-%22Reverse-Pairs%22
- Series of Stock: 
https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems
- Monotonic Queue:
 https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems
- Monotonic Stack: 
https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems
- Lazy Initialization:
https://leetcode.com/problems/design-a-stack-with-increment-operation/discuss/539716/JavaC%2B%2BPython-Lazy-increment-O(1)

# Systems Design
https://github.com/donnemartin/system-design-primer
https://www.hiredintech.com/classrooms/system-design/lesson/55

# Scalability
http://highscalability.com/

# Leadership Principles / Behavioral / The Interview Itself
https://business.linkedin.com/content/dam/me/business/en-us/talent-solutions/resources/pdfs/linkedin-30-questions-to-identify-high-potential-candidates-ebook-8-7-17-uk-en.pdf
LinkedIn top interview questions
https://haseebq.com/how-to-break-into-tech-job-hunting-and-interviews/ the job seeking / interview process
https://medium.com/@nick.ciubotariu/ace-the-coding-interview-every-time-d169ce1fd3fc
https://leetcode.com/discuss/interview-experience/680549/google-amazon-l3l4-sde2-june-2020-pending-offer good post for whole process
https://interviewgenie.com/blog-1/category/Amazon+interviews
https://medium.com/@scarletinked/are-you-the-leader-were-looking-for-interviewing-at-amazon-8301d787815d

# Solving:

## General:
https://leetcode.com/explore/interview/card/top-interview-questions-easy/
https://www.teamblind.com/post/New-Year-Gift---Curated-List-of-Top-100-LeetCode-Questions-to-Save-Your-Time-OaM1orEU
https://leetcode.com/problemset/top-100-liked-questions/
https://leetcode.com/discuss/general-discussion/677506/top-50-google-tagged-questions-with-links

## Basic Topics:
http://www.ardendertat.com/2012/01/09/programming-interview-questions/
https://www.geeksforgeeks.org/commonly-asked-data-structure-interview-questions-set-1/?ref=lbp
https://www.geeksforgeeks.org/commonly-asked-algorithm-interview-questions-set-1/?ref=lbp
https://leetcode.com/discuss/career/448024/Topic-wise-problems-for-Beginners
https://leetcode.com/discuss/interview-question/344650/Amazon-Online-Assessment-Questions

## Paradigms:
https://leetcode.com/discuss/general-discussion/491522/dynamic-programming-questions-thread

## Patterns:
https://leetcode.com/discuss/general-discussion/457546/LeetCode-Problem-Patterns-from-***
https://leetcode.com/discuss/career/448285/List-of-questions-sorted-by-common-patterns

## Blind/Company-wise:
https://leetcode.com/list/xi4ci4ig/
https://www.geeksforgeeks.org/interview-preparation-for-software-developer/?ref=leftbar
https://www.geeksforgeeks.org/must-do-coding-questions-for-companies-like-amazon-microsoft-adobe/?ref=lbp
https://www.geeksforgeeks.org/must-coding-questions-company-wise/?ref=leftbar-rightbar#sap

## Microsoft:
https://leetcode.com/discuss/interview-question/398023/Microsoft-Online-Assessment-Questions
https://www.geeksforgeeks.org/microsofts-asked-interview-questions/
https://www.geeksforgeeks.org/microsofts-most-frequently-asked-interview-questions-set-2/

## Amazon:
https://leetcode.com/discuss/interview-question/383669/

## Facebook:
https://leetcode.com/discuss/general-discussion/675445/facebook-interview-experiences-all-combined-from-lc-till-date-07-jun-2020

## Google:
-more google questions

------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------





# EXTRAS:
------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------

# Competitive Programming
> You need to learn C++ for CP, Java is too slow of a language
https://codeforces.com/blog/entry/57282
https://www.quora.com/How-is-competitive-programming-different-from-real-life-programming
https://www.quora.com/What-have-you-gained-from-competitive-programming-Did-you-go-into-research-Did-it-help-you-in-any-aspect-as-a-software-engineer-Did-it-help-you-get-an-in-depth-knowledge-of-a-programming-language-Did-it-affect-your-problem-solving-skills
https://www.quora.com/What-is-the-best-way-to-teach-competitive-programming-to-a-total-beginner/answer/Ashish-Gupta-211?share=bc64fd2a&srid=ihpN
https://github.com/lnishan/awesome-competitive-programming

LC contests
Codeforces
Topcoder
AOPS
Project Euler
SPOJ


# Languages
C++:
- Effective C++
- Accelerated C++
- C++ Primer

Python:
- Python: Automate the boring stuff

# Reading List
- The C Programming Language. 2nd Edition - Kernighan and Ritchie - Short but critical
- Grokking Algorithms- Aditya Bhargava - Good introduction to algorithms, easy to understand conceptually
- Intro to Algorithms - GeeksforGeeks
- Programming Interviews Exposed - Coding Your Way Through the Interview-Wrox (2018) - John Mongan, Noah Kindler, Eric Giguère
- Cracking the Coding Interview - 189 Programming Questions and Solutions-CareerCup (2015) - Gayle Laakmann McDowell - The King
> Start grinding LeetCode here
- Grokking the System Design Interview - System Design
- Clean Code - A Handbook of Agile Software Craftsmanship-Prentice Hall (2008) - Robert C. Martin
- Introduction to Algorithms - Cormen (CLRS)
- The Algorithm Design Manual-Springer-Verlag London (2008) - Steven S. Skiena
- Computer Systems: A Programmer's Perspective - Bryant and O'Hallaron
- Software Engineering - Ian Sommerville
- Fundamentals of Database Systems - Navathe - Databases
- Database System Concepts - Korth - Databases
- Computer Networking - A Top Down Approach - Kurose - Networking
- Operating System Concepts - Silberschatz & Gagne - OS

> Further readings:
- Software Requirements - Wiegers
- Structure and Interpretation of Computer Programs - Abelson & Sussman
- Compilers - Aho
- The Art Of Computer Programming - Knuth
- The Relational Model For Database Management - Codd
- Refactoring to Patterns - Kerievsky
- Patterns of Enterprise Applications - Fowler
- How to Design Programs - Felleisen
- Code Complete - McConnell
- Something on Security
- Clean architecture
- Pragmatic programmer
- Clean coder.
- Design patterns - gang of 4.
- Refactoring.
- Google Site Reliability - https://landing.google.com/sre/books/

# Clean Code
> Code is clean if it can be understood easily – by everyone on the team. Clean code can be read and enhanced by a developer other than its original author. With understandability comes readability, changeability, extensibility and maintainability.

- General rules:
   > Follow standard conventions.
   > Keep it simple stupid. Simpler is always better. Reduce complexity as much as possible.
   > Boy scout rule. Leave the campground cleaner than you found it.
   > Always find root cause. Always look for the root cause of a problem

- Design rules:
   > Keep configurable data at high levels.
   > Prefer polymorphism to if/else or switch/case.
   > Separate multi-threading code.
   > Prevent over-configurability.
   > Use dependency injection.
   > Follow Law of Demeter. A class should know only its direct dependencies.

- Understandability tips:
   > Be consistent. If you do something a certain way, do all similar things in the same way.
   > Use explanatory variables.
   > Encapsulate boundary conditions. Boundary conditions are hard to keep track of. Put the processing for them in one place.
   > Prefer dedicated value objects to primitive type.
   > Avoid logical dependency. Don't write methods which works correctly depending on something else in the same class.
   > Avoid negative conditionals.

- Names rules:
   > Choose descriptive and unambiguous names.
   > Make meaningful distinction.
   > Use pronounceable names.
   > Use searchable names.
   > Replace magic numbers with named constants.
   > Avoid encodings. Don't append prefixes or type information.

- Functions rules:
   > Small.
   > Do one thing.
   > Use descriptive names.
   > Prefer fewer arguments.
   > Have no side effects.
   > Don't use flag arguments. Split method into several independent methods that can be called from the client without the flag.

- Comments rules:
   > Always try to explain yourself in code.
   > Don't be redundant.
   > Don't add obvious noise.
   > Don't use closing brace comments.
   > Don't comment out code. Just remove.
   > Use as explanation of intent.
   > Use as clarification of code.
   > Use as warning of consequences.

- Source code structure:
   > Separate concepts vertically.
   > Related code should appear vertically dense.
   > Declare variables close to their usage.
   > Dependent functions should be close.
   > Similar functions should be close.
   > Place functions in the downward direction.
   > Keep lines short.
   > Don't use horizontal alignment.
   > Use white space to associate related things and disassociate weakly related.
   > Don't break indentation.

- Objects and data structures:
   > Hide internal structure.
   > Prefer data structures.
   > Avoid hybrids structures (half object and half data).
   > Should be small.
   > Do one thing.
   > Small number of instance variables.
   > Base class should know nothing about their derivatives.
   > Better to have many functions than to pass some code into a function to select a behavior.
   > Prefer non-static methods to static methods.

- Tests:
   > One assert per test.
   > Readable.
   > Fast.
   > Independent.
   > Repeatable.

- Code smells
   > Rigidity. The software is difficult to change. A small change causes a cascade of subsequent changes.
   > Fragility. The software breaks in many places due to a single change.
   > Immobility. You cannot reuse parts of the code in other projects because of involved risks and high effort.
   > Needless Complexity.
   > Needless Repetition.
   > Opacity. The code is hard to understand.

------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------

# More System Design and Scalability:
I'm following up from my previous post and sharing some data points on my sys design approach. 
https://www.teamblind.com/post/How-I-got-into-FAANG-FpwTWHuo

It is not an exhaustive list and might not work for everyone. Also it is not a one size fits all thing but I hope it helps you to draft a plan and figure out how to tackle the sys design.

Resources:
1. https://github.com/donnemartin/system-design-primer
2. https://github.com/binhnguyennus/awesome-scalability
3. Youtube InfoQ channel - https://www.youtube.com/user/MarakanaTechTV
4. Youtube SDE Skills channel - https://www.youtube.com/channel/UCPumyEKs86w-GtWDd2XQYtg
5. Amazon DynamoDB - https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf
6. Grokking the sys design interview - https://www.educative.io/courses/grokking-the-system-design-interview

Process:
- I started with reading Amazon DynamoDB paper. This is a very practical paper to understand consistent hashing. 
- I also started spending time on Donne Martin Sys Design (resource 1) and tried to go through each section. I went through this page 2-3 times entirely to develop some understanding (my philosophy is to read one book 10 times than reading ten books 1 time). I was not just reading it page but making my notes summarizing each building block, its usage, common systems where it is used and its drawbacks.
- For each component (whether it is a caching, messageQ, DBs) I searched for Youtube videos and gathered more info on it. I penned it down in my notes, copied any diagram I found its usage in, stored links to videos or blogs I saw mentioned something useful about it.
- I started reading cloud design pattern - https://docs.microsoft.com/en-us/azure/architecture/patterns/ - It has some good info on what the nomenclature is and how some components are typically used.
- I started going over practical system designs - Read mostly from Uber blog, Facebook blog and Yelp architecture.
- I read about few system design practical questions and analyzed what sort of things I need to address there - Grokking the sys design and Donne Martin has some good examples on these.
- Before each interview I only referred to my notes on various components/building blocks instead of researching again.
- Finally I made sure I practiced on whiteboard with solving 2-3 sys design problems. Idea was to complete them in 45 mins (more on this below).

My 9 Step approach
------------------------
1. Gather requirements(use case, who is customer, why is this needed etc.) 
2. Discuss system constraints (any limitations, what is allowed vs what is not)
3. Do capacity estimation, specifically 
  - traffic estimation (read request per sec, write requests per sec) 
  - storage estimation (storage needed to store worth 3 yrs of stored 'object') 
  - bandwidth estimate (#of bytes/sec system should handle for incoming and outgoing traffic) 
  - cache estimate (memory needed to cache some of the hot read responses, 80-20 rule)

4. Define System APIs - Rest style mostly (read about Rest vs Soap)
5. Draw top level system diagram (client, web servers, platform, database, worker services)  
6. Discuss database design choice (schema, SQL or no-SQL) 
7. Perfect your design for a single user -> get a Minimum Viable Product 
8. Discuss scaling 
  - find bottlenecks and single point of failures (put load balancer, caching, replication, Message queues, Asynchronous workers) 
9. Test and Review your design (Treat this one as same what you do in coding interview)
  - walk through your system and see if we met each customers need
  - did we provide APIs for each customer ask 
  - did we walk over failover scenarios (not just vanilla passing case) 
  - did we draw system boundaries/or blocks to explain different parts of systems

If you manage to get all these steps in 45 mins you've probably addressed most of the interviewer concerns :)

Some practical examples (see if above 9 steps are followed here):
Design Tiny URL: http://tinyurl.com/jlg8zpc

Design Instagram: https://www.educative.io/collection/page/5668639101419520/5649050225344512/5673385510043648

Some tricks you'll need:
1. You need to know some common sys design patterns. If you tell I'll solve this by using 'Consistent Hashing' you don't have to waste your time and explain this whole thing on whiteboard. Interviewer can also see you know the common industry stuff and where to use it. Just say the name and keep moving.
2. When interviewer interrupts you in your design and asks a question, don't be defensive and start proving what you've done is correct. You might be correct or you are being asked to suggest alternatives for the design choice you made - knowing what building blocks exist helps here.
3. Try to reach to step 8 in the 45 mins discussion. Have some rough diagram on board like below to convey what you are saying (not just doing hand wavy stuff)

What didn't work out for me:
In my last Google(L5) interview the 9 step process I listed above didn't work out. First the interview was a virtual one so it was getting very difficult for me to draw the diagram on screen. Secondly the interviewer was getting anxious and kept interrupting me to get to the scaling part in step 5 itself. I kept reminding him I'll answer this in just a moment. The final feedback I got from recruiter was Interviewer gave me hints to solve the problem :)

What worked for me:
In my FB sys design I just followed these 9 steps and interviewer didn't interrupt me anytime. He probably only spoke handful of words apart from his intro during the whole interview :)
